| Вопрос        | Ответ           | Question in english  | Answer in english  |
| ------------- |-------------| -------------|-------------|
| что такое void *?| Это значает указатель на какой либо случайную область памяти  | what is void*?| void * means "a reference to some random chunk o' memory with untyped/unknown contents"|
|а что означает просто void? | Означает возвращаемое значение функции. Метод не возвращает ничего, результат не может быть ничему присвоен | and what does simply void mean?| The (void) indicates the return type. This method doesn't return anything, so its result can't be assigned to anything.|
|в чем разница между void * и id?|id означает ссылку на случайный объект objective-c неизвестного класса| what's the difference between void* and id |id means "a reference to some random Objective-C object of unknown class"|
|что такое id? | указатель на объект неизвестного класса| what is id?|refrence to some random object of unknown class|
|как определен id?|typedef struct objc_object { Class isa; } *id;|how id id defined?|typedef struct objc_object { Class isa; } *id;|
|можно ли создать структуру и привести к id?|можно использовать NSValue valueWithPointer|Can we cast struct to id?|Use NSValue's +valueWithPointer: method to encapsulate the pointer in ani object for the purposes of spinning off the thread. NSValue does no automatic memory management on the pointer-- it really is juste an opaque object wrapper for pointer values.|
|id vs instancetype|Лучше использовать instancetype потому, что id не дает никакой проверки типов. С instancetype IDE и компилятор знают какой тип возврщается  и могут проверить код лучше и лучше отработает автокомплит|id vs instancetype|There definitely is a benefit of using instancetype. When you use 'id', you get essentially no type checking at all. With instancetype, the compiler and IDE know what type of thing is being returned, and can check your code better and autocomplete better.|
|что значит root класс?|Рутовый класс эт класс у которого нет родительского супер класса|what does root class mean?|A root class in ObjC is a class which has no superclass; it is the ultimate base class from which other classes are typically derived. The standard root class for almost all objects in the Cocoa frameworks is NSObject, although there are others eg NXProxy|
|можно ли создать свой root класс?
|какие есть еще root классы кроме NSObject и NSProxy?|Никакие|Are there any other root classes except NSObject and NSProxy| No|
|можно ли использовать NSObject вместо NSProxy?|Плюс NSProxy в том что он не имплементирует большинтсов методов. Если использвоать NSObject то множество методов будет отправлено без возмжности перенаправить их|Can we use NSObject instead of NSProxy|The point of NSProxy is that it doesn't implement most methods. That's necessary to be sure that the Objective-C forwarding machinery gets invoked to begin with. If you start with NSObject, there are a lot of methods which will just be directly dispatched without you having an opportunity to forward them.|
|если ответ «да», то зачем тогда нужен NSProxy?|См выше|If the anser is yes why do we need NS Proxy?|Look above|
|как происходит выравнивание указателей на объекты в objc?|Под ним имеется в виду то, что указатель на какой-либо тип данных должен быть кратным степени двойки. Например, указатель на 4-х байтовый int должен быть кратен четырём.Если вы создате переменную, компилятор может проверить выравнивание. днако, всё становится не так просто в случае динамически выделяемой памяти. У malloc нет никакого представления о том, какого типа будут данные, он просто выделяет четыре байта, не зная о том, int это, или два shortа, четыре charа, или вообще что-то ещё. И потому, чтобы соблюсти правильное выравнивание, он использует совсем уж параноидальный подход и возвращает указатель выравненный так далеко, чтобы эта граница подошла для абсолютно любого типа данных. В Mac OS X, malloc всегда возвращает указатели, выравненные по границе 16-и байтов.Из-за выравнивания, в указателе остаются неиспользованные биты.Последняя цифра hex всегда нуль.Зная о пустых битах в конце указателя, можно пойти и дальше и попытаться найти им применение. Почему бы не использовать их как индикатор того, что это не настоящий указатель на объект? Тогда мы могли бы хранить данные прямо здесь, в самом указателе, без необходимости выделять дорогую память? Да-да, это и есть те самые меченые указатели.Системы, в которых используются меченые указатели, осуществляют дополнительную проверку — они смотрят на младший бит, и если он равен нулю — перед нами настоящий объект. Если же это единица, то перед нами не объект а что-то другое, и информацию из указателя придется извлекать нестандарнтым путем.Все это можно реализовать различными способами, но в Objective-C младший бит меченого указателя всегда равен единице, а последующие три обозначают класс указателя.Наблюдательный читатель, наверное, уже заметил, что у нас остается всего 28 бит на 32-разрядной системе и 60 на 64-разрядной. А целые могут принимать и большие значения. Все верно, не каждый int можно спрятать в меченом указателе, для некоторых придется создавать полноценный объект.|Objective c pointer alighnment how dows it work?|This means that a pointer to a particular data type should be a multiple of some power of two. For example, a pointer to a 4-byte integer should be a multiple of 4 on most architectures. If you make a local variable, the compiler can ensure that the alignment is correct. However, things are not so simple for dynamically allocated memory. malloc has no idea what kind of data the program is going to be storing. It gets a request for 4 bytes (assuming that int is 4 bytes), but it has no idea if this is an int, a pointer (on 32-bit platforms), two shorts, four chars, or something else.malloc has no idea what kind of data the program is going to be storing. It gets a request for 4 bytes (assuming that int is 4 bytes), but it has no idea if this is an int, a pointer (on 32-bit platforms), two shorts, four chars, or something else.What if we took advantage of those unused low bits in a pointer to indicate that this is not a real pointer? What if we then stored the object data inline in the rest of this non-pointer instead of off in a separate memory allocation? The result of doing so is a tagged pointer.Systems which use tagged pointers require an extra check. Any time an object pointer is used, the system checks the low bit. If it's zero, it's a real object pointer and treated normally. If the low bit is one, then it can't be a real pointer, since it's not correctly aligned. In that case, the pointer is handled specially.For whatever reason, the Objective-C implementation of tagged pointers has the bottom bit always set to 1 in a tagged pointer, with the other three bits indicating the class of the tagged pointer.The observant reader will notice that the space left for storing the value is smaller than that of a plain integer. After using 4 bits for the tag, there are 28 bits left for a value on 32-bit systems, and 60 bits left for a value on 64-bit systems.Integers which require more than 28 or 60 bits to store can't be placed in a tagged pointer, and will have to be stored in a regular object.|
|с чем это связано?|||
|какие оптимизации с этим связаны при хранении данных?|Экономия памяти путем храенения данных в ниеиспользованных битах в указателях а также выигрыш по производительсности за счет отсутствия операций выделению памяти|what optimizations exist in pointer algingment and tagged pointers|We benefit from tagged pointers because data is stored inside pointer's unused bytes and cpu benefit from absence of memeory allocation opertaions|
|почему нельзя делать свою реализацию?|меченые указатели — это очень, очень закрытое API, поэтому нельзя даже и думать о том, чтобы использовать их в реальном проекте. Под определение класса объекта выделено всего три бита — итого одновременно могут быть задействованы всего восемь классов. Если вы случайно пересечетесь с классом, использованным Apple — все, беда.|why we should not make our own implementation?|Note that tagged pointers are very, very, very private and cannot under any circumstances be used in any real code. There are an extremely limited number of tagged pointer classes. Since there are only three bits of tag available to indicate the class, only eight tagged classes can be used. If your tagged class conflicts with one in the frameworks, it's game over.|
|что такое bridge и зачем это нужно?|Это нужно для переноса указателей в область контроля ARC и обратно.(__bridge T) op приводит операнд к результирующему типу Т. Если Т ритейновы тип тогда операнд должен быть не ритейновым. Если Т неритейновый тип указателя то опренад должен быть ритейновым. При этом не происходит передачи владения указателем ARC не не добавляет операцию ритейн. (__bridge_retained T) op привди операнд. который должен быть ритейновым, к результирующему типу который должен быть не ритейновым. ARC ритейнит значение и адресат уже сам дожен позаботится о том, чтобы сблансировать +1 в счетчике ссылок. (__bridge_transfer T) op приводит операнд, который должен быть неритейновым типом указателя, к результирующему типу который дложен быть ритейновым. ARC зарелизит значение в конце выражения.|What is bridge and what is it used for?|These casts are required in order to transfer objects in and out of ARC control.(__bridge T) op casts the operand to the destination type T. If T is a retainable object pointer type, then op must have a non-retainable pointer type. If T is a non-retainable pointer type, then op must have a retainable object pointer type. Otherwise the cast is ill-formed. There is no transfer of ownership, and ARC inserts no retain operations. (__bridge_retained T) op casts the operand, which must have retainable object pointer type, to the destination type, which must be a non-retainable pointer type. ARC retains the value, subject to the usual optimizations on local values, and the recipient is responsible for balancing that +1.(__bridge_transfer T) op casts the operand, which must have non-retainable pointer type, to the destination type, which must be a retainable object pointer type. ARC will release the value at the end of the enclosing full-expression, subject to the usual optimizations on local values.|
|что такое мета-класс?
|objc_msgSend, что это за функция?|Компилятр автомтатически генерирует вызовы objc_msgSend когда встречает выражения отправики сообщения объекту и Objective C. Не все вызовы испольлзуютс objc_msgSend. Из за сложностей abi есть отдельные функции для того чтобы вернуть float например и структуру. Например если метод осуществлет определенный поиск и возврщает NSRange структуру нужно будет вызвать objc_msgSend_stret. И если это неправильно определить то программа будет работать неправитьно или будет креш. |What is objc_msgSend function?|The compiler automatically generates calls to objc_msgSend() (or some variant thereof) when it encounters Objective-C messaging expressions.Not all message sends use the objc_msgSend() function itself. Due to complications and requirements in the ABI (in the calling convention of functions, in particular), there are separate functions for returning, for example, floating-point values or structures. For example, in the case of a method that performs some sort of searching (substrings, etc.), and it returns an NSRange structure, depending on the platform, it may be necessary to use the structure-returning version of the messenger function.And if you get this wrong (e. g. you use the inappropriate messenger function, you mix up the pointers to the return value and to self, etc.), your program will likely behave incorrectly and/or crash.|
|как это связано с [obj foo]? какие еще есть связанные функции?|См выше||Look above|
|что такое dispatch table?|Поиск метода происходит по dispatch table у isa, уходя вниз. Именно поэтому все методы в Objective-C являются виртуальными, включая private.И поэтому же мы можем обратиться в метод, зная его селектор. Ключом в dispatch table является SEL (селектор, подробный разбор), а значением IMP (реализация, самая обычная C функция). По рисунку, таблица дочернего класса не включает в себя таблицу родительского класса, но использует композицию. Значит категория срабатывает на всем проекте, а не только в файлах, где мы ее включили, используя include/import.|||
|как происходит отправка сообщения?|objc_msgSend по указателю isa переходит на мета класс чтобы найти диспатч таблицу и смотрит есть ли там вызваемый метод. Если нет, то пытается найти метод в таблице суперкласа (родителя). Если и там нет то идет вверх по дереу пока не достингнет nsObject. И еслои там не найдено тоже то здесь вывзвается исключение.|How message s dispatched?|objc_msgSend() function follows the isa pointer to the class object, to the find this table, and checks whether the method is in the table for the class. If it cannot find it, it looks for the method in the table of the class's superclass. If not found, it continues up the object tree, until it either finds the method or gets to the root object (NSObject). At this point, an exception is thrown.|
|всегда ли сообщения отправляются с одинаковой скоростью?|Для того, чтобы увеличить скорость отправки сообщения система кэширует селекоторы и адреса методов по мере их использования. Есть отдельный кэш для каждого класса и в нем могут неаходится селеторы наследуемых методов так и его собственные селекторы. Подсистема сообщенйи сначала смотрит на кэш класса объекат получающего сообщения прежде чем смотреть диспатч таблицы. Если он нашел селектор в кэше то вызов лишь слегка медленее вызвова функции. Когда программа уже давно работает кэш прогревается и почти все вызовы селекторов идут через кэш. Кэш растет динамически. |Is the mehtod always envoked with the same speed?|To speed the messaging process, the runtime system caches the selectors and addresses of methods as they are used. There’s a separate cache for each class, and it can contain selectors for inherited methods as well as for methods defined in the class. Before searching the dispatch tables, the messaging routine first checks the cache of the receiving object’s class (on the theory that a method that was used once may likely be used again). If the method selector is in the cache, messaging is only slightly slower than a function call. Once a program has been running long enough to “warm up” its caches, almost all the messages it sends find a cached method. Caches grow dynamically to accommodate new messages as the program runs.|
|что будет если метод не найден в dispatch table?|Будет смотреть в таблице суперкласса рекурсивно|What will happen if method is not found in dispathc table|Runtime will look in superclass's dispatch table recursively till NSObject|
|есть ли в objc приватные методы?|Нет|Private methods do they exist in ObjC|No|
|как протестировать метод, не объявленный в публичном интерфейсе|прописать категорию которая будет высталвять наружу приватные методы|How to test a method that is not exposed in public interface|Create a category to expose methods from internal interfce|
|exception отправки сообщения, кто выбрасывает?||||
|что такое NSInvocation. Привести пример использования|Это дейтсвие превращенное в объект. NSInvocation нуюно когда сообщение нужно отправить объекту в другое время или несколько раз. NSInvocation позволяет поисать сообщение которые вы собираетесь отправлять, а потом вызвать его|What is nsinvocation? usage example|An NSInvocation is an Objective-C message rendered static, that is, it is an action turned into an object.NSInvocation comes in handy when you want to send a message to an object at a different point in time, or send the same message several times. NSInvocation allows you to describe the message you are going to send, and then invoke it (actually send it to the target object) later on|
|что такое swizzling?|Замера реализации метода в рантайме на другую method_exchangeImplementations|What is method swizzling. |It is exchange of one method implementation to another's in runtime|
|можно ли сделать private ivar как property, через категорию?||||
|какие проблемы могут быть?
|как в категории сделать свою property?|В Objective c есть такая вещь как ассоциированные объекты|Can we make a property inside category?|Objective-C runtime has this thing called Associated Objects that can do exactly what is needed. objc_setAssociatedObject|
|как сделать так, чтобы по селектору был вызван не метод, а блок?|Нужно использвать внутренний класс обертку. Это простой класс у которого есть атрибут блок и метод кторый запускает этот блок. Категория создает эту обертку передает в нее блок который должен быть вызван, а далее говорит себе использовать метод обертки. Категория использует ассциированные объекты для хранения оберток.|How to implement block invokation using selector|We're using a custom "internal only" class called ActionWrapper. This is a simple class that has a block property (the block we want to get invoked), and a method that simply invokes that block. The UIControl category simply instantiates one of these wrappers, gives it the block to be invoked, and then tells itself to use that wrapper and its invokeBlock: method as the target and action (as normal).The UIControl category uses an associated object to store an array of ActionWrappers, because UIControl does not retain its targets. This array is to ensure that the blocks exist when they're supposed to be invoked.|
|что такое селектор?|typedef struct objc_selector 	*SEL;|what is selector?|typedef struct objc_selector *SEL;|
|что такое блок?|Это анонимная функция в OBJC|What is a block|It is an anonymous function in ObjC|
|какие типы блоков бывают?|глобальные( без состояния ), локальные или они же стековые, и блоки в куче (MallocBlock)|what types of blocks exist?|global, local or stack blocks, blocks in heap|
|от какого класса наследуются?|NSObject|What class is block superclass?|NSObject|
|всегда ли использование self внутри блока означает retain cycle?| Не всегда если self не ритейнит блок то цикла не будет. Цикл например возникает если вызвается блок который одновременно является сильным пропери self|Is it always that usgin self inside block leads to retain cycle|If self does not retain block simultaneousely there will be no retain cycle. If self holds strong refrerence to the block there will be|
|почему внутри блока используется неявное const?|Чтобы переменные не исчезли на время выполнения блока|Why blocks use implicit const?|To make sure variables do not disappear during block execution|
|как работает __block|Переменые помеченные как __block работают так как будтно они выделены в хранилище и оно автоматически восстанавливается после последнего использования переменной. Реализация может использовать оптимизацию в которой хранилище выделяется в кучу только в момент block_copy ссылающегося блока. Такие переменные могут быть изменениы как обычные.|How does __block qualifier work?|Variables qualified by __block act as if they were in allocated storage and this storage is automatically recovered after last use of said variable. An implementation may choose an optimization where the storage is initially automatic and only "moved" to allocated (heap) storage upon a Block_copy of a referencing Block. Such variables may be mutated as normal variables are.|?
|как происходит вызов блока?||||
|внутри блока используется assert, какие проблемы возникают?||||
|как их устранить без выделения в отдельный метод?||||
|что такое assert и когда использовать?|Assert служит для того чтобы убедится что значение пременной такое какое должно быть. Если assert завершается не успешно то это значит что что-то пошло не так и приложение завершает работу|what is assert and when to use it?|Assert is to make sure a value is what its supposed to be. If an assertion fails that means something went wrong and so the app quits|
|что такое __autoreleasing?|__autoreleasing означает что аргумент передатеся по ссылкк и релизится по кокончании| what is __autoreleasing?|__autoreleasing to denote arguments that are passed by reference (id *) and are autoreleased on return.|
|что такое autorelease pool?|Концепция autorelease pool давольно проста. коль скоро экземпляр объекта помчен как autorelease и его количсетсво ссылок увеличено на 1 на некоторое время , но в конце итерации run loop количетсво ссылок любого объекта помеченного как autoresease будет уменьшено. Это способ держать объект во время того как вы подготоваливаете что-то что будет держать объекта для него же.|what is autoresease pool?|The concept of an autorelease pool is simple, whenever an object instance is marked as autoreleased (for example NSString* str = [[[NSString alloc] initWithString:@"hello"] autorelease];), it will have a retain count of +1 at that moment in time, but at the end of the run loop, the pool is drained, and any object marked autorelease then has its retain count decremented. It's a way of keeping an object around while you prepare whatever will retain it for itself.|
|что такое run loop?|Runloop это бастракция которая предоставляет механизм для обработки системных утсройтсв ввода (коеты, порты. файлы, клава, мышь итд) Кажждый NSThread имеет свой runloop, к оторому можно получить доступк через currentRunLoop method. В общем случае нет необходимости обрщаться к runloop напрямую, хотя есть некоторые компоненты ввода вывода которые могут допустить укзаать runloop с которым им надо работать. Runloop для конкретного потока будет ждать до тех пор пока один из его источников для ввода не получит какието данные или события, затем запустит необходимый обработчик чтобы обработать каджый готовый источник. После этого он венется к своему циклу, рбрабатывая другие события, или перейдет в состояния сна если нет никакой работы для выполенения.|what is runloop?|A run loop is an abstraction that (among other things) provides a mechanism to handle system input sources (sockets, ports, files, keyboard, mouse, timers, etc).Each NSThread has its own run loop, which can be accessed via the currentRunLoop method.In general, you do not need to access the run loop directly, though there are some (networking) components that may allow you to specify which run loop they will use for I/O processing.A run loop for a given thread will wait until one or more of its input sources has some data or event, then fire the appropriate input handler(s) to process each input source that is "ready.".After doing so, it will then return to its loop, processing input from various sources, and "sleeping" if there is no work to do.That's a pretty high level description (trying to avoid too many details).|
|как связаны NSTimer и run loop?
|как запустить таймер на отдельном потоке?
|что будет если запустить таймер и держать UIScrollView?
|как это исправить?
|как связаны run loop и autorelease pool?|В конце итерации run loop autorelease pool очищается|run loop and autorelease pool how they are connected|autorelease pool is drained in the end of run loop iteration|
|какие типы управления памятью есть в objc?|ARC MRC|what kind of memory menagement aproaches exist in obj c| ARC MRC|
|garbage collection vs reference counting?|Подсчет ссылок представляет лучшее от ручного управления памятью и отслеживания и сбора мусора. Он в основном избалвяет разрабточика в ручную отслеживать ретейны релизы и авторелизы, но также позволяет избежать тяжелого процесса сборки мусора, что в условиях ограниченных ресурсов мобильного устройтсва может вызвать лаги. ARC добавляет необходимые ритейны и релизы во время компиляции, следуя правилам которым следовали все  разрботчики долгие годы. Псокольку управление памятью идет во время компиляции нет необхджимости в процессе, который бы постоянно прелопачивал память и укничтожал объекты на которых нету ссылок. Преимуществом сборки мусора я является возможность определять ретейн циклы и успешно их обрабатывать.|garbage collection vs reference counting?|RC can provide the best of both manual memory management and tracing garbage collection. It mostly removes the need for a developer to track manual retains, releases, and autoreleases on Objective-C objects, yet avoids the need for a garbage collector process which can use up limited resources on a mobile device and cause occasional stutters in a running application.ARC inserts the appropriate retains and releases required for reference counting at compile time, by applying the rules that all Objective-C developers have had to use over the years. This frees the developer from having to manage this themselves. Because the retains and release are inserted at compile time, no collector process is needed to continually sweep memory and remove unreferenced objects.One slight advantage that tracing garbage collection has over ARC is that ARC will not deal with retain cycles for you, where tracing garbage collection can pick these up.|
|отличия ARC от MRC?|ARC система проставляет ритейны релизы во время компиляции, ритейны и релизы в коде запрещены. В MRC руками просталвяются|Differences between ARC MRC|In ARC system inserts releases and retains in compile time, manual retinas and releases are firbidden. In MRC developer is responsible for placin retains and releases where appropriate|
|как работает ARC? магически определяет когда удалять объект?|В первой фазе Clang исследует каждый пре обработанный файл на наличие объектов и свойств. Далее он добавляет необходимы ритейны релизы авторелизы по финсированным правилам. Например, если объект создан и является локальным для метода, то релиз выражене для него вставляется в конец метода. Если это свойтсво класса, то релиз добавляется в метод dealoc класса. Если объект это возврщаемое знанчиение или является частью коллекции, то он получает выражение авторелиз. Первая фаза также проставляет ретейны для объектов, которыми класс не владеет локально. Он обновляет все аксессоры помеченные @property. Он добавяет релизы в родительский dealloc. Также информирует о ручных выраженя управления памятью и о двусмысленно владении. На второй фазе происходит опитимизация. Происходит подсчет ритейнов и релизв для каждого обжекта и компилятор располагает их парами исходя из оптимального минимума. Это исключает изыбточные ритейны или релизы что положительно сказывается на производительности.|How does ARC work? magically detects when to dispose an object?|In the front-end phase, Clang examines each pre-processed file for objects and properties. It then inserts the right retain, release, and autorelease statements based on some fixed rules.For example, if the object is allocated and local to a method, it gets a release statement near the end of that method. If it is a class property, its release statement goes into the class' dealloc method. If the object is a return value or is part of a collection object, it gets an autorelease statement. And if the object is weakly referenced, it is left alone.The front-end also inserts retain statements for objects not locally owned. It updates any accessors declared with the directive @property. It adds calls to the parent's dealloc routine, and it reports any explicit management calls and any ambiguous ownership.In the optimize phase, Clang subjects the modified sources to load balancing. It counts the retain and release calls made for each object, then pares them to the optimal minimum. This avoids excessive retains and releases, which can impact on overall performance.|
|напишите реализацию сеттера на MRC||||
|чем отличается weak от strong и почему так много runtime функций для этого?|Стронг свойство определяет владение над объектом т.е колчиество ссылко увеличено на 1. Weak отсутствие владения.|What's the difference betweem weak and strong|Strong property exresses the ownership on the object, weak does not|
|почему weak невозможно использовать на некоторых классах?||||
|на каких именно?||||
|как быть в этом случае?||||
|ARC, как работает dealloc?||||
|когда расставляются release сообщения для ivar?||||
|что такое union?|Это структура данных которая позволяет хранить более одного типа данных водном хранилище.|what is union?|Unions are a data construct that allow you to store more than one type of data in the same storage area.|
|что такое volatile?|Для компилятора это означает что он не должен предполагать что переменная имеет какое-либо значение в только потому что у нее было такое значение пикосекунду назад и вроде нет кода, который бы ее менял. Не вжно. При достпуке к переменной всегда читать ее текущее значение.|What is volatile?|For the compiler that means it must not assume that a has a certain value just because it used to have that value 1 pico-second ago and there was no code that seemed to have changed it. Doesn't matter. When accessing a, always read its current value.|
|что такое inline функции?|Это инстуркция компилятору встроить функцию в то место, откуда она вызывается, с целью увеличения скорости выолпнения. static означает что имя функции не линкуется гдето во вне. используется для маленьких и быстрых функций встривание которых обычно работает быстрее вызова отдельной копии.|What is inline function?|inline does not mean you can use the function “inline” (it is normal to use functions inside other functions; you do not need inline for that); it encourages the compiler to build the function into the code where it is used (generally with the goal of improving execution speed).static means the function name is not externally linked. If the function were not declared static, the compiler is required to make it externally visible, so that it can be linked with other object modules. To do this, the compiler must include a separate non-inline instance of the function. By declaring the function static, you are permitting all instances of it to be inlined in the current module, possibly leaving no separate instance.static inline is usually used with small functions that are better done in the calling routine than by using a call mechanism, simply because they are so short and fast that actually doing them is better than calling a separate copy.|
|в чем отличие потока от процесса?||||
|NSThread vs pthread||||
|сокет, как это связано с вопросами выше?||||
|tcp, udp когда что применять?|В обзем, если нужно чтобы ответ содержался в одном пакете, и вы готовы к самостоятельной реализации протокола надежной доставки  или повторной отправки нужен UDP. DNS отличный пример данного случая. Цена установки соединения слишком высока. Другой случай когда можно допустить потерю данных, тк  как новая порация данных заменит потерянную. НАпример передача инормации о погоде, видео стриминг, или данные видео игры. В противном случе придется хранить слишком много состоняи и ОС не сможет это позволить. Это довольно редкий случайц в наши дни. По факту сейчас TCP стеки которые могут быть использованы таким образом что программист получит самый высокий уровень контроля за TCP состоянием. ДО 2003 года UDP был единствено возможным выбором. UDP может быть отправлен нескольким хостам одновременно, TCP такого не умеет|When to use udp when tcp?|In general, you want the answer to be in one response packet, and you are prepared to implement your own protocol for reliability or to resend. DNS is the perfect description of this use case. The costs of connection setups are way too high (yet, DNS does support a TCP mode as well).Another case is when you are delivering data that can be lost because newer data coming in will replace that previous data/state. Weather data, video streaming, a stock quotation service (not used for actual trading), or gaming data comes to mind.Another case is when you are managing a tremendous amount of state and you want to avoid using TCP because the OS cannot handle that many sessions. This is a rare case today. In fact, there are now user-land TCP stacks that can be used so that the application writer may have finer grained control over the resources needed for that TCP state. Prior to 2003, UDP was really the only game in town. One other case is for multicast traffic. UDP can be multicasted to multiple hosts whereas TCP cannot do this at all.|
|гонка потоков, методы синхронизации, защита критической секции, семафор, мьютекс, барьер, что это и зачем нужно?|Критическая секция - объект синхронизации потоков, позволяющий предотвратить одновременное выполнение некоторого набора операций (обычно связанных с доступом к данным) несколькими потоками. Критическая секция выполняет те же задачи, что и мьютекс.В операционных системах семейства Microsoft Windows разница между мьютексом и критической секцией в том, что мьютекс является объектом ядра и может быть использован несколькими процессами одновременно, критическая секция же принадлежит процессу и служит для синхронизации только его потоков.Захват критической секции означает атомарное увеличение переменной на 1. Переход к ожиданию на событии ядра осуществляется только в случае, если значение переменной до захвата было уже больше 0, то есть происходит реальное «соревнование» двух или более потоков за ресурс.Семафо?р (англ. semaphore) — объект, ограничивающий количество потоков, которые могут войти в заданный участок кода.|||
|что такое OSSpinLock?||||
|как передавать данные между NSOperation?||||
|когда операция отправленная в NSOperationQueue начинает выполняться, можно ли отложить выполнение?||||
|как тестировать асинхронные методы?||||
|как написать синхронную обертку для асинхронного метода?||||
|что такое стек вызовов и как это работает?||||
|в чем отличие стека от кучи?|||The stack is the memory set aside as scratch space for a thread of execution. When a function is called, a block is reserved on the top of the stack for local variables and some bookkeeping data. When that function returns, the block becomes unused and can be used the next time a function is called. The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer.The heap is memory set aside for dynamic allocation. Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns.|
|int8_t matrix[2048][2024], допустимо ли?|На iOS размер стека ограничен 1MB для основного потока и 512 кб для второстепенных, а здемсь объявлено 4 мегабайта где-то|||
|рекурсивные функции и хвостовая рекурсия, любая ли рекурсия может быть хвостовой?|Хвостовая рекурсия — частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом из функции. Второй вопрос странен сам по себе.|||
|что происходит со счетчиком ссылок когда объект добавляется в array, dictionary, set?|Счетчик ссылок увеличится на 1 при добавлении|||
|если нужно другое поведение, что использовать?|||you can't make NSArray store weak references. The easiest way to implement Emile's suggestion of wrapping an object inside another object that stores a weak reference to it is using nsValue valueWithNonretainedObject. iOS6 and OSX 10.8 supposedly offer a better solution:[NSHashTable weakObjectsHashTable][NSPointerArray weakObjectsPointerArray][NSPointerArray pointerArrayWithOptions:]|
|можно ли узнать, какой объект сколько раз был добавлен в set? (bag)||||
|как использовать свой класс как ключ?|Должен реализовывать протокол NSCopying|||
|в чем плюсы использования immutable?|||Both mutable and immutable objects have their own uses, pros and cons.Immutable objects do indeed make life simpler in many cases. They are especially applicable for value types, where objects don't have an identity so they can be easily replaced. And they can make concurrent programming way safer and cleaner (most of the notoriously hard to find concurrency bugs are ultimately caused by mutable state shared between threads). However, for large and/or complex objects, creating a new copy of the object for every single change can be very costly and/or tedious. And for objects with a distinct identity, changing an existing objects is much more simple and intuitive than creating a new, modified copy of it.|
|в чем минусы?|||Look above |
|зачем нужен атрибут copy для property и какую проблему решает?|||'copy' will cause the setter for that property to create a copy of the object, and is otherwise identical to strong. You would use this to make sure that if someone sets your property to a mutable string, then mutates the string, you still have the original value. If the string isn't mutable, Cocoa will silently optimize out the copy operation, which is nice :)|
|почему и как работает KVC?|||First of all, keep in mind that Objective-C is a dynamic language. Essentially, each class maintains a mapping of method names to their actual implementations (which are just C functions). This is akin to the dictionary you talk about, although it is managed by the Objective-C runtime itself.This mapping is used every time a method is called. For example, let's say you have this bit of code:[obj doSomething];What really happens is that, at runtime, the Objective-C runtime searches obj's method mapping for an entry called "doSomething". This returns a function that the runtime then calls, passing in obj as the first parameter to that function.Because methods are dispatched at runtime, Objective-C provides a number of ways to call functions using strings. (This is akin to doing something like getattr(obj, "doSomething")() in Python, if you're familiar with Python.)The Objective-C runtime itself also tracks the names of instance variables and where they are actually located in memory, relative to an object.This is how KVC is able to do its thing. The KVC runtime uses the Objective-C runtime to first look for a method called setProperty. The runtime fetches the function corresponding to that method, and the KVC machinery can then call that method, passing obj and @"value" as the parameters to that function.What if a method can't be found? Well, then the KVC machinery looks for an instance variable with the same name, using a function from the Objective-C runtime like ivar_getOffset or the like. Probably at some point it uses a function like object_setIvar to set the instance variable. (This is speculation, but I think it's a pretty good guess as to how KVC works vis-a-vis instance variables.)|
|key-path, хаки для коллекций||||
|зачем нужен NSMapTable, какие отличия от NSHashTable|тличие в том что Maptable может хранить слабые ссылки, у нее нет mmutalble вериии|||
|проблемы при работе с KVO и как это все работает|KVO — это технология, позволяющая незамедлительно реагировать в одном объекте (наблюдателе) на изменения состояния другого объекта (наблюдаемого), без внесения знаний о типе наблюдателя в реализации наблюдаемого объекта.NSKeyValueObserving является неформальным протоколом, реализованным в классе NSObject, позволяющим подписать произвольный объект (наблюдатель) на изменения значения по указанному key path указанного другого объекта (наблюдаемого), вызвав на нем селектор addObserver:forKeyPath:options:context:. После этого при каждом изменении значения наблюдатель будет получать сообщение observeValueForKeyPath:ofObject:change:context:, аналогично паттерну делегирования.Наблюдение не создает сильных ссылок ни на наблюдателя, ни на наблюдаемый объект, ни на контекст.Контекст для KVO является обычным указателем из языка C. Даже если он указывает на объект Objective C, KVO не будет рассматривать его как таковой: не будет слать ему сообщений или отслеживать его время жизни. Следовательно, если контекст будет удален, то в observeValueForKeyPath будет передана «висячая» ссылка, и попытка передать по ней сообщение приведет к последствиям bad accesss.Если удаленным окажется наблюдаемый объект, то вместо того, чтобы прекратить наблюдение (ведь никакие значения меняться больше не могут), в консоль будет выведено предупреждение.was deallocated while key value observers were still registered with it. Observation info was leaked, and may even become mistakenly attached to some other object|||
|frame, bounds, center, как все это между собой связано?|||Frame A view's frame (CGRect) is the position of its rectangle in the superview's coordinate system. By default it starts at the top left.\Bounds A view's bounds (CGRect) expresses a view rectangle in its own coordinate system.Center A center is a CGPoint expressed in terms of the superview's coordinate system and it determines the position of the exact center point of the view. http://stackoverflow.com/questions/5361369/uiview-frame-bounds-and-center|
|как изменятся свойства, если применить поворот на 45??|||Look above|
|как передвинуть все subviews на 3 pt вверх и влево?||||
|отличие view от layer?|||On iOS, every UIView is backed by a Core Animation CALayer, so you are dealing with CALayers when using a UIView, even though you may not realize it. Unlike NSViews on the Mac, which evolved before Core Animation existed, UIViews are intended to be lightweight wrappers around these CALayers.|
|responder принцип работы||| responder is an object that can respond to events and handle them. All responder objects are instances of classes that ultimately inherit from UIResponder (iOS) or NSResponder (OS X). These classes declare a programmatic interface for event handling and define a default behavior for responders. The visible objects of an app are almost always responders—for example, windows, views, and controls—and the app object is a responder as well. In iOS, view controllers (UIViewController objects) are also responder objects.The First Responder is a very specific concept in Cocoa. The only time iOS decides to set the First Responder is when a text field gets focus. At all other times you must explicitly control which object you want to be the first responder (see -canBecomeFirstResponder, -becomeFirstResponder).There is no such thing as a second responder.All responders have a NextResponder, (which can be nil). This means that starting from any responder there may be (but may not be) an arbitrarily length chain of responders (responder -> nextResponder -> nextResponder -> etc) along which events are passed until they are handled.There is a default chain which can be view -> superview -> superview but might also include UIViewControllers, UIWindows, UIWindowControllers, UIApplication and more, so it heavily depends on your object hierarchy (not just your view hierarchy - so no, you can't say nextResponder is always the parent view).|
|как отправить сообщение по responder chain?|||hittest withevent|
|как работают категории?|добавляет методы в ispathc table класса|||
|в какой момент происходит влияние на классы?||||
|что будет если категории пересекутся?|||тоже самое как если два одинаковым метода в классе написать|
|зачем у категории есть имя?|||The name of a category is almost entirely useless, with the exception being that the nameless category (i.e. ()) is reserved for class extensions|
|зачем нужен NSCache? В чем от реализации кэша на NSDictionary?|||he NSCache class incorporates various auto-removal policies, which ensure that it does not use too much of the system’s memory. The system automatically carries out these policies if memory is needed by other applications. When invoked, these policies remove some items from the cache, minimizing its memory footprint.You can add, remove, and query items in the cache from different threads without having to lock the cache yourself.Retrieving something from an NSCache object returns an autoreleased result.Unlike an NSMutableDictionary object, a cache does not copy the key objects that are put into it.|
|поддерживает ли NSURLConnection протокол HTTP/2?|||HTTP/2 is only supported by NSURLSession|
|какая типизация у objc? Сильная/слабая, явная/не явная, статическая/динамическая?|Статическая Слабая Явная|||
|в чем отличие QoS User-interactive и user-initiated?|||UserInteractive QoS is used for work directly involved in providing an interactive UI such as processing events or drawing to the screen. UserInitiated QoS is used for performing work that has been explicitly requested by the user and for which results must be immediately presented in order to allow for further user interaction. For example, loading an email after a user has selected it in a message list.|
|в чем отличие nil/Nil/NULL/NSNull?|#define NULL ((void *)0) #define nil (id)0 #define Nil (Class)0 NSNull Foundation|||
